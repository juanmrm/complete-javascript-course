ES2015 y ES6 se refieren a la misma versión de Javascript publicada en 2015.
Se le llama también ES6 porque se ha lanzado después de la ES5 publicada en 2009.

Actualmente no podemos utilizar ES6 en Producción, porque no está completamente soportada por los 
Browsers. Es muy útil usar un Transpiler ES6 -> ES5 como Babel.

1 - Let and Const

  let: equivale al antiguo var, valores que pueden mutar, cambiar.
  const: para constantes (variables inmutables), valores que no pueden cambiar.

  Diferencias: 
    - var tiene scope function mientras que let y const tiene scope block
    - una variable var se puede utilizar antes de ser declarada (temporal dead zone and hoisting), no vale con let y const.
    - podemos declarar la misma variable 2 veces pero no podemos hacerlo con let o const

2 - Blocks and IIFEs (Data privacy)

  Ahora disponemos de una forma muy sencilla de crear IIFEs.
  Para crear un bloque hacemos { codigo... }

3 - Strings

    - String Templates. Mas rápido y fácil de usar. Ponemos ` en lugar de " o ' y marcamos los placeholders con ${...},
        p.e: console.log(`He is ${calcAge(year)} years old`).

    - New methods: 
        startsWith: ver si empieza por...
        endsWith: ver si termina en...
        includes: ver si incluye...
        repeat: repetir un string n veces

4 -  Arrow Functions

    Para escribir menos codigo en tareas tipicas como iterar sobre un array y devolver un resultado.
      - La mas simple con 1 solo argumento y 1 linea de codigo que lleva implícito el return
         array.map(el => ...);
      - Con mas argumentos, 2 por ejemplo
         array.map((el, index) => ...);
      - Con más argumentos y más de una linea de codigo
         array.map((el, index) => { 
           ...
           return value;
         });

    p.e: ages6 = years.map((el, index) => `Age element ${index + 1}: ${new Date().getUTCFullYear() - el}.`);

    Lexical 'this' keyword: las arrow function comparten el this de la funcion que las envuelve.

5 - Destructuring

  Nos da una forma correcta de extraer datos de un Object o Array, más sencilla y corta de escribir.
    p.e: const [name, age] = ['John', 26];

  Es muy util para devolver multiples valores en una funcion. En ES5 lo que devolveriamos seria un Object.

6 - Arrays
    Nuevos metodos y formas de iterar.

    Para convertir un objeto lista a array:
      ES5: boxesArray5 = Array.prototype.slice.call(boxes); // Hack para transformar nodeList a array
      ES6: const boxesArray6 = Array.from(boxes);

    Bucles: el problema con forEach y map es que no podemos usar break o continue keyword.
      En ES5 tendriamos que utilizar un for loop tradicional. 
      En ES6 usaremos un forof loop
        for (const cur of object) {...}

    Para buscar elementos: 
      - findIndex
      - find

7 - Spread operator: used in function call
  Un manera muy conveniente de expandir los elementos de un array o lista en sitios como argumentos o llamadas a funciones.
    p.e: en ES5: var sum = addFourAges.apply(null, ages); // Llama a la funcion pasandole el array como argumento
         en ES6: const sum = addFourAges(...ages);
                 const bigFamily = [...familySmith, 'Lily', ...familyMiller];

8 - Rest Parameters in Functions: used in function declaration

  Nos permiten pasar un numero arbitrario de parametros a una funcion y utilizar estos argumentos en la funcion
   p.e: function isFullAge6(limit, ...years) {...}

9 - Default Parameters

  Cuando queremos que determinados argumentos de la funcion tengan valores por defecto.
    p.e:  function SmithPerson(firsName, yearOfBirth, lastName = 'Smith', nationality = 'american') {...}

10 - Maps

  Nueva estructura de datos key-value de ES6.
  La creamos con const map = new Map();
  Añadimos: map.set(key, value), donde key puede ser string, number, boolean...
  Recuperar: map.get(key);
  Tamaño: map.size
  Elimiar: map.delete(key)
  Comprobar si existe una clave: map.has(key)
  Eliminar todos los elementos: map.clear()

  Iteraremos con forEach o con forof loops

  Por qué un Map es mejor estructura de datos que un Object?
    - En un Map podemos utilizar cualquier cosa como key no solo Strings
    - Son Iterables
    - Muy sencillo obtener el tamaño
    - Muy facil añadir / eliminar elementos

11 - Classes:

  No añaden nada nuevo al lenguaje. Son sintactic sugar sobre la forma en la que hacemos herencia y prototipado,
  en Javascript, pero es más sencillo de escribir.

  class Person {
    constructor(...)

    method1() {...}
  }

  Podemos añadir static methods: son metodos que están vinculados a la clase, no a la instancia de la clase.

  2 Consideraciones importantes:
    - Class definitions are not hoisted
    - Solo podemos añadir metodos a las clases, no propiedades.
    (Prototypes having data properties is generally considered an anti-pattern, so this just enforces a best practice.)

12 - Classes with Subclasses:

  En ES5: Athlete5.prototype = Object.create(Person5.prototype); // Person5 es la clase padre de Athlete5 que es la subclase.
  En ES6: class Athlete6 extends Person6 y en el constructor usaremos super(...)

13 - How to use ES2015 / ES6 Today

  https://babeljs.io/
  npm install --save-dev babel-cli babel-preset-es2015 babel-polyfill

  .\node_modules\.bin\babel --presets es2015 my-challenge-solution.js --out-file transpiled.js
  
  En el html:
    <script src="polyfill.min.js"></script>
    <script src="transpiled.js"></script>